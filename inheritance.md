# Наследование

## Задача 1 

Создайте базовый класс `HeavenlyBody`, который включает в себя:

- строку документирования класса '''Родительский класс HeavenlyBody''';
- конструктор, инициализирующий атрибуты Небесных тел: `name`, `age`, `temperature` и `radius` (название, возраст, температура и радиус объекта);
- метод `display()` для отображения свойств объекта.

Затем добавьте два подкласса `Planet` и `Star`, которые наследуют методы и свойство от класса `HeavenlyBody`, и кроме того, имеют свои атрибуты. 

Подкласс `Planet`: 

- содержит строку документирования класса '''Дочерний класс Planet''';
- содержит конструктор, инициализирующий дополнительно атрибут `orbital_speed` (орбитальная скорость);
- переопределяет метод `display()` для включения свойства `orbital_speed`. 

Подкласс `Star`: 

- содержит строку документирования класса '''Дочерний класс Star''';
- содержит конструктор, инициализирующий дополнительно атрибут `constellation` (созвездие);
- переопределяет метод `display()` для включения свойства `constellation`.

Выведите на экран документацию дочерних классов, затем метод `display()`для отображения свойств каждого объекта.

**Пример использования:**

```python
if __name__ == '__main__':
  planet1 = Planet('Земля', 4540, '16.92', 6371, '29.8')
  star1 = Star('Полярная звезда', 60, '5500', 47, 'Малая Медведица')
  
  print(Planet.__doc__, end='\n')
  planet1.display()
  
  print(Star.__doc__, end='\n')
  star1.display()
```

**Вывод:**

    Дочерний класс Planet
    Название: Земля
    Возраст: 4540 (млн. лет)
    Температура: 16.92 (С)
    Радиус: 6371 (км)
    Орбитальная скорость: 29.8 (км/с) 
    
    Дочерний класс Star
    Название: Полярная звезда
    Возраст: 60 (млн. лет)
    Температура: 5500 (С)
    Радиус: 47 (км)
    Созвездие: Малая Медведица 

## Задача 2

Совсем недавно Вы решили открыть кондитерский бизнес. В настоящее время Ваш магазин кондитерских изделий обрел большое количество клиентов. Ежедневно кондитеры выпекают более тонны выпечки, поэтому требуется внимательно отслеживать каждый заказ и срок годности выпечки. 

Для начала создайте базовый класс `Pastry`, который содержит: 

- конструктор, инициализирующий атрибуты кондитерских изделий: `name`, `price`, `manufacture_date` и `term` (наименование, цена, дата изготовления и срок годности);
- метод `display()` для отображения информации о выпечке;
- метод `valid_until()`, который позволяет вычислить срок годности рассматриваемого изделия.

Торты и капкейки - это самые популярные позиции кондитерской. Добавьте два дочерниих класса `Cake` и `Cupcake`, которые наследуют все свойства и методы от класса `Pastry`, и кроме того, имеют свои атрибуты. 
Подкласс `Cake` содержит атрибут `filling` (начинка). Подкласс `Cupcake` содержит атрибут `amount` (количество). Метод `order()` в дочерних классах выводит полную информацию о выпечке и осуществляет проверку срока годности. Если изделие свежее, тогда можно оформить заказ. 

**Пример использования:**

```python
if __name__ == '__main__': 
  cake1 = Cake('Бенто торт', 1300, datetime.date(2023, 7, 20), 3, 'вишня')
  cupcake1 = Cupcake('Капкейк', 300, datetime.date(2023, 7, 20), 4, 20)

  cake1.order()
  cupcake1.order()
```

**Вывод:**

    Название: Бенто торт
    Цена: 1300 (руб.)
    Дата изготовления: 2023-08-07
    Начинка: вишня
    Срок годности истекает через 3 дня
    Оформлен заказ 2150189619152 - Бенто торт с начинкой вишня 
    
    Название: Капкейк
    Цена: 300 (руб.)
    Дата изготовления: 2023-08-07
    Количество: 20
    Срок годности истекает через 4 дня
    Оформлен заказ 2150189619792 - Капкейк, необходимое количество 20

  ## Задача 3
  
  Создайте базовый класс `BankAccount`, который:
  
  - содержит конструктор, инициализирующий атрибуты Банковских аккаунтов: приватный атрибут: `holder` (владелец), публичные: `balance` и `interest_rate` (баланс и процентная ставка);
  - содержит методы getter и setter для приватного атрибута
  - переопределяет магический метод `__str__()`.
  
  Затем добавьте дочерний класс `BankOperation`, который наследует все свойства и методы от класса `BankAccount`, и кроме того, имеет свои методы:
  
  - `deposit(amount)` добавляет сумму к балансу и регистрирует транзакцию
  - `withdraw(amount)` вычитает сумму из баланса и записывает транзакцию;
  - `add_interest()` добавляет проценты к счету на основе `interest_rate` и записывает транзакцию
  - `history()` печатает список всех операций по счету
  
  **Пример использования:**
  
  ```python
if __name__ == '__main__':
  account = BankOperation('Warren Buffett', 113000000000, 0.08)
  
  account.__str__()
  account.deposit(4000000000)
  account.withdraw(88000000000)
  account.add_interest()
  account.history()
```

**Вывод:**

  Владелец: Warren Buffett
  
  Баланс: \$113,000,000,000.00
  
  Процентная ставка: 0.08 

  
  Аккаунт 2289924818704 - внесение наличных на счет: \$4,000,000,000.00
  
  Аккаунт 2289924818704 - cнятие наличных: \$88,000,000,000.00
  
  Аккаунт 2289924818704 - начислены проценты по вкладу: \$2,320,000,000.00


## Задача 4

В большинстве случаев в программировании лучше избегать сложных конструкций. В программе ниже представлена визуализация множественного ромбовидного наследования по MRO. Мы видим, что класс `Copier` унаследовал функциональность более чем одного класса. Изучите программу написанную ниже и постарайтесь оветить на вопросы: 1)Почему каждый метод `__init__` вызывался только один раз? 2)Почему каждый метод `__init__` был запущен до того, как любой из других был завершен?

   ```python
  class ComputerDevice:
      '''Request process'''
  
      def __init__(self, inf):
          print('Start init ComputerDevice.__init__()')
          self.inf = inf
          print('End init ComputerDevice.__init__()')
  
  class Scanner(ComputerDevice):
      '''Scan information'''

      def __init__(self, inf):
          print('Start init Scanner.__init__()')
          super().__init__(inf)
          print('End init Scanner.__init__()')
  
  
  class Printer(ComputerDevice):
      '''Print information'''
  
      def __init__(self, inf):
          print('Start init Printer.__init__()')
          super().__init__(inf)
          print('End init Printer.__init__()')
  
  
  class Copier(Scanner, Printer):
      '''Copy process'''

      def __init__(self, inf):
          print('Start init Copier.__init__()')
          super().__init__(inf)
          print(f'Отсканированная информация: {self.inf.upper()}')
          print('End init Copier.__init__()')

  print(Copier.__mro__)
```

**Пример использования:**

```python
if __name__ == '__main__':
  c = Copier('Hello world!')
```

**Вывод:**

```python
  Start init Copier.__init__()
  Start init Scanner.__init__()
  Start init Printer.__init__()
  Start init ComputerDevice.__init__()
  End init ComputerDevice.__init__()
  End init Printer.__init__()
  End init Scanner.__init__()
  Отсканированная информация: HELLO WORLD!
  End init Copier.__init__()
```


